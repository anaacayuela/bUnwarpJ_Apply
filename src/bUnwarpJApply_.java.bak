import java.awt.Color;
import java.awt.image.ColorModel;
import java.util.Enumeration;
import java.util.Locale;
import java.util.Vector;
import ij.*;
import ij.process.*;
import ij.gui.*;
import java.awt.*;
import java.awt.image.*;

import ij.gui.GenericDialog;
import ij.io.FileInfo;
import ij.macro.Interpreter;
import ij.measure.Calibration;
import ij.measure.Measurements;
import ij.plugin.ChannelArranger;
import ij.plugin.ChannelSplitter;
import ij.plugin.Concatenator;
import ij.plugin.HyperStackReducer;
import ij.plugin.PlugIn;
import ij.plugin.RGBStackMerge;
import ij.*;
import ij.process.*; 
import bunwarpj.BSplineModel;
import bunwarpj.MiscTools;
import fiji.util.gui.GenericDialogPlus;

public class bUnwarpJApply_ implements PlugIn, Measurements {
	private int channelSource=1;
	private ImagePlus impbSource;
	ImagePlus[] images;
	String TransfPath;
	
	@SuppressWarnings("deprecation")
	public void run(String arg) {
	  	 ImagePlus imp = IJ.getImage();
	  	 if (!showDialog(imp))
			return;
	  	 
	 	 if (imp.getImageStackSize() < channelSource) {
	 		IJ.error("Cannot find the channel number "+channelSource);
	 		return;
	 	 }

    	int intervalsSource=MiscTools.numberOfIntervalsOfTransformation(TransfPath);
		double [][]cxSource = new double[ intervalsSource+3 ][ intervalsSource+3 ];
		double [][]cySource = new double[ intervalsSource+3 ][ intervalsSource+3 ];
		MiscTools.loadTransformation(TransfPath, cxSource, cySource);
		
		
		 String sourceTitle = impbSource.getTitle();
			ImageStack outputStackSource = 
					new ImageStack( impbSource.getWidth(), impbSource.getHeight() );

			// apply transform to each slice of the stackSource

			for( int i=1; i<=imp.getImageStackSize(); i++ )
			{
				ImageProcessor ipSource = impbSource.getImageStack().getProcessor( i );
				BSplineModel source = new BSplineModel( ipSource, false, 1 );
				ImagePlus movingImageSource = new ImagePlus("", ipSource );			
				ImageProcessor resultSource = 
						MiscTools.applyTransformationMT( 
							movingImageSource, impbSource, source, intervalsSource, cxSource, cySource );
				outputStackSource.addSlice( "", resultSource );
			}
		
			// return resultsSOurce
			ImagePlus finalSource = new ImagePlus (impbSource.getTitle() +"-transformed",outputStackSource);
//			IJ.run(impbTarget, "Red","");
//			IJ.run(finalSource, "Green","");
//			if (impbTarget.getBitDepth()== 8) {
//			IJ.run(finalSource, "8-bit", "");
//			}
//			if (impbTarget.getBitDepth()== 16) {
//				IJ.run(finalSource, "16-bit", "");	
//			}
//			if (impbTarget.getBitDepth()== 32) {
//			IJ.run(finalSource, "32-bit", "");
//			}
			finalSource.show();
			impInicial.hide();
			RGBStackMerge rgM = new RGBStackMerge();
			rgM.mergeStacks();
			imp.hide();
			ImagePlus impFinal = IJ.getImage();
			ImagePlus[] channels = ChannelSplitter.split(impFinal);
			channels[0].show();
			channels[1].show();
			
			
	}
	
	
	boolean showDialog(ImagePlus imp) {
		GenericDialogPlus gd = new GenericDialogPlus("bUnwarpJ Apply");
		if (imp.getNChannels() > 1) {
    		gd.addStringField("Channel to be transformed: ", "2");
    		gd.addDirectoryOrFileField("Load the Transformation file (Filename like this: C+ChannelToBeTransformed-imageTitle_direct_transf.txt)", TransfPath);
    		
		}
		
		gd.showDialog();
		if(gd.wasCanceled())
			return false;
		if(gd.invalidNumber()) {
			IJ.error("Error", "Invalid input number");
			return false;
		}
		
		if (imp.getNChannels() > 1) {
			String channelStrSource= gd.getNextString();
			if (channelStrSource  =="R")
				channelSource = 1;
			else if (channelStrSource=="G")
				channelSource = 2;
			else if (channelStrSource =="B")
				channelSource = 3;
			else
				channelSource=Integer.parseInt(channelStrSource);
		}
		TransfPath = gd.getNextString();
		
		return true;
	}

	private ImagePlus extractChannel(ImagePlus imp, int channel) {

        int width = imp.getWidth();
        int height = imp.getHeight();
        int zslices = imp.getNSlices();
        int frames = imp.getNFrames();
        
        FileInfo fileInfo = imp.getOriginalFileInfo();
        // create empty stack
        ImageStack stack2 = new ImageStack(width, height);
        // create new ImagePlus for selected channel
        ColorProcessor cp = new ColorProcessor(imp.getImage());
        ByteProcessor  bp = cp.getChannel(channel, null);
        ImagePlus imp2 = new ImagePlus("C" + channel + "-" + imp.getTitle(), bp);
    			

        // copy slices
        for (int t = 1; t <= frames; t++)
            for (int z = 1; z <= zslices; z++) {
                int sliceOne = imp.getStackIndex(channel, z, t);
                stack2.addSlice("", imp.getStack().getProcessor(sliceOne));
            }
        imp2.setStack(stack2);
        imp2.setDimensions(1, zslices, frames);
        if (zslices * frames > 1)
            imp2.setOpenAsHyperStack(true);
        imp2.setFileInfo(fileInfo);
        imp2.updateAndDraw();
        return imp2;
    }

		
	
}